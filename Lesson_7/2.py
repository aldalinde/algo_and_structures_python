"""
2. Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50). Выведите на экран исходный
и отсортированный массивы.
"""

import random

# функция сортировки
def sort_array(array):
    return sorted(array)

# функция создания списка
def array():
    array = [random.randint(0, 50) for n in range(30)]
    return array

# функция сортировки слиянием с использованием рекурсии (для разделения списка на две части и выделения пар из двух чисел)
def sort_merge(array):
    # базовый случай рекурсии  - длина части достигает меньше 2, тогда возвращаем это оставшееся число - каждый раз
    # это следующее число в списке
    part_length = len(array)
    if part_length < 2:
        return array

    # рекурсивно разбиваем список на две части
    else:
        # две переменные, содержащие одна первую, другая - вторую половину списка
        mer_1 = sort_merge(array[:part_length//2])
        mer_2 = sort_merge(array[part_length//2:part_length])

        # введение пустого списка и счетчиков прибавления в него результатов сравнения чисел из разных частей
        counter_1 = 0
        counter_2 = 0
        sorted = []
        # цикл сравнений и добавлений, выполняемый, пока хоть один счетчик не достиг текущей длины своей
        # части (пока меньше ее)
        while counter_1 < len(mer_1) or counter_2 < len(mer_2):
            # если счетчик добавлений первого списка становится равен длине первой части -
            # добавляется элемент из второй части, сравнивавшийся последним, но не добавленный ( = по индексу счетчику)
            if counter_1 >= len(mer_1):
                sorted.append(mer_2[counter_2])
                counter_2 += 1
            # если счетчик добавлений второго списка становится равен длине своей (второй) части -
            # добавляется элемент из первой части, сравнивавшийся последним, но не добавленный ( = по индексу счетчику)
            elif counter_2 >= len(mer_2):
                sorted.append(mer_1[counter_1])
                counter_1 += 1
            # добавляется меньший из сравниваемых (они в каждый момент последние) в двух частях
            elif mer_1[counter_1] < mer_2[counter_2]:
                sorted.append(mer_1[counter_1])
                counter_1 += 1
            elif mer_1[counter_1] >= mer_2[counter_2]:
                sorted.append(mer_2[counter_2])
                counter_2 += 1
        # отсортированная часть передается каждый раз в качестве "хвоста" к еще не отсортированному
        return sorted



# для проверки выводим случайный ряд и уже сотрированный ряд
check = array()
print(check)
print(sort_array(check))

# вызываем функцию нахождения медианы без сортировки и выводим ее результат
print(sort_merge(check))